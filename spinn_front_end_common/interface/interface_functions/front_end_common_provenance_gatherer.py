# pacman imports
from pacman.interfaces.abstract_provides_provenance_data import \
    AbstractProvidesProvenanceData
from pacman.model.placements.placement import Placement
from spinn_machine.progress_bar import ProgressBar

# front end common imports
from pacman.utilities.utility_objs.provenance_data_item import \
    ProvenanceDataItem
from spinn_front_end_common.utilities import exceptions
from spinn_front_end_common.utilities.utility_objs.\
    provenance_data_items import ProvenanceDataItems


class FrontEndCommonProvenanceGatherer(object):
    """
    """

    def __call__(self, transceiver, machine, router_tables, has_ran,
                 placements, provenance_data_objects=None):
        """
        :param transceiver: the SpiNNMan interface object
        :param machine: the python representation of the spinnaker machine
        :param router_tables: the router tables that have been generated
        :param has_ran: token that states that the simulation has ran
        :return: none
        """

        if not has_ran:
            raise exceptions.ConfigurationException(
                "This function has been called before the simulation has ran."
                " This is deemed an error, please rectify and try again")

        if provenance_data_objects is not None:
            prov_items = provenance_data_objects
        else:
            prov_items = ProvenanceDataItems()

        self._write_router_provenance_data(
            router_tables, machine, transceiver, prov_items)

        progress = ProgressBar(placements.n_placements,
                               "Getting provenance data")

        # retrieve provenance data from any cores that provide data
        for placement in placements.placements:
            if isinstance(placement.subvertex,
                          AbstractProvidesProvenanceData):

                # get data
                prov_data_items = \
                    placement.subvertex.get_provenance_data_items(
                        transceiver, placement)
                prov_items.add_provenance_item_by_location(
                    placement, prov_data_items)

            progress.update()
        progress.end()

        return {'prov_items': prov_items}

    def _write_router_provenance_data(
            self, router_tables, machine, txrx, prov_items):
        """ Writes the provenance data of the router diagnostics

        :param router_tables: the routing tables generated by pacman
        :param machine: the spinnMachine object
        :param txrx: the transciever object
        :param prov_items: the prov item container
        :return: None
        """
        progress = ProgressBar(
            machine.n_chips,
            "Getting provenance data from machine's routing tables")

        # acquire diagnostic data
        router_diagnostics = dict()
        reinjector_statuses = dict()
        for router_table in router_tables.routing_tables:
            x = router_table.x
            y = router_table.y
            if not machine.get_chip_at(x, y).virtual:
                router_diagnostic = txrx.get_router_diagnostics(x, y)
                router_diagnostics[x, y] = router_diagnostic
                reinjector_status = txrx.get_reinjection_status(x, y)
                reinjector_statuses[x, y] = reinjector_status

        for x, y in router_diagnostics:
            self._write_router_diagnostics(
                x, y, router_diagnostics[x, y], reinjector_statuses[x, y],
                prov_items)
            progress.update()
        for chip in machine.chips:
            if not chip.virtual:
                if (chip.x, chip.y) not in router_diagnostics:
                    router_diagnostic = \
                        txrx.get_router_diagnostics(chip.x, chip.y)
                    has_dropped_mc_packets = \
                        router_diagnostic.n_dropped_multicast_packets != 0
                    has_local_multicast_packets = \
                        router_diagnostic.n_local_multicast_packets != 0
                    has_external_multicast_packets = \
                        router_diagnostic.n_external_multicast_packets != 0
                    reinjector_status = \
                        txrx.get_reinjection_status(chip.x, chip.y)
                    if (has_dropped_mc_packets or
                            has_local_multicast_packets or
                            has_external_multicast_packets):
                        self._write_router_diagnostics(
                            chip.x, chip.y, router_diagnostic,
                            reinjector_status, prov_items)
                        progress.update()
        progress.end()

    @staticmethod
    def _write_router_diagnostics(
            x, y, router_diagnostic, reinjector_status, prov_items):
        """
        stores router diagnostics as a set of provenance data items
        :param x: x coord of the router in question
        :param y: y coord of the router in question
        :param router_diagnostic: the router diagnostic object
        :param reinjector_status: the data gained from the reinjector
        :param prov_items: the provenance data items
        :return: None
        """
        placement = Placement(None, x, y, None)
        prov_items.add_provenance_item_by_location(
            placement, ProvenanceDataItem(
                name="Loc__MC",
                item=str(router_diagnostic.n_local_multicast_packets),
                needs_reporting_to_end_user=False))
        prov_items.add_provenance_item_by_location(
            placement, ProvenanceDataItem(
                name="Ext__MC",
                item=str(router_diagnostic.n_external_multicast_packets),
                needs_reporting_to_end_user=False))
        prov_items.add_provenance_item_by_location(
            placement, ProvenanceDataItem(
                name="Dump_MC",
                item=str(router_diagnostic.n_dropped_multicast_packets),
                needs_reporting_to_end_user=
                router_diagnostic.n_dropped_multicast_packets > 0,
                message_to_end_user=
                "This router has dropped {} multicast route packets. "
                "Try increasing the machine_time_step and/or the time scale "
                "factor or reducing the number of atoms per core."
                .format(router_diagnostic.n_dropped_multicast_packets)))
        prov_items.add_provenance_item_by_location(
            placement, ProvenanceDataItem(
                name="Loc__PP",
                item=str(router_diagnostic.n_local_peer_to_peer_packets),
                needs_reporting_to_end_user=False))
        prov_items.add_provenance_item_by_location(
            placement, ProvenanceDataItem(
                name="Ext__PP",
                item=str(router_diagnostic.n_external_peer_to_peer_packets),
                needs_reporting_to_end_user=False))
        prov_items.add_provenance_item_by_location(
            placement, ProvenanceDataItem(
                name="Dump_PP",
                item=str(router_diagnostic.n_dropped_peer_to_peer_packets),
                needs_reporting_to_end_user=False))
        prov_items.add_provenance_item_by_location(
            placement, ProvenanceDataItem(
                name="Loc__NN",
                item=str(router_diagnostic.n_local_nearest_neighbour_packets),
                needs_reporting_to_end_user=False))
        prov_items.add_provenance_item_by_location(
            placement, ProvenanceDataItem(
                name="Ext__NN",
                item=str(
                    router_diagnostic.n_external_nearest_neighbour_packets),
                needs_reporting_to_end_user=False))
        prov_items.add_provenance_item_by_location(
            placement, ProvenanceDataItem(
                name="Dump_NN",
                item=str(router_diagnostic.n_dropped_nearest_neighbour_packets),
                needs_reporting_to_end_user=False))
        prov_items.add_provenance_item_by_location(
            placement, ProvenanceDataItem(
                name="Loc__FR",
                item=str(router_diagnostic.n_local_fixed_route_packets),
                needs_reporting_to_end_user=False))
        prov_items.add_provenance_item_by_location(
            placement, ProvenanceDataItem(
                name="Ext__FR",
                item=str(router_diagnostic.n_external_fixed_route_packets),
                needs_reporting_to_end_user=False))
        prov_items.add_provenance_item_by_location(
            placement, ProvenanceDataItem(
                name="Dump_FR",
                item=str(router_diagnostic.n_dropped_fixed_route_packets),
                needs_reporting_to_end_user=False))
        if reinjector_status is not None:
            prov_items.add_provenance_item_by_location(
                placement, ProvenanceDataItem(
                    name="ReceivedForReinjection",
                    item=reinjector_status.n_dropped_packets,
                    needs_reporting_to_end_user=False))
            prov_items.add_provenance_item_by_location(
                placement, ProvenanceDataItem(
                    name="MissedForReinjection",
                    item=reinjector_status.n_missed_dropped_packets,
                    needs_reporting_to_end_user=
                    reinjector_status.n_missed_dropped_packets > 0,
                    message_to_end_user=
                    "This reinjector has missed {} packets.".format(
                        reinjector_status.n_missed_dropped_packets)))
            prov_items.add_provenance_item_by_location(
                placement, ProvenanceDataItem(
                    name="ReinjectionOverflows",
                    item=reinjector_status.n_dropped_packet_overflows,
                    needs_reporting_to_end_user=
                    reinjector_status.n_dropped_packet_overflows > 0,
                    message_to_end_user=
                    "This reinjector has dropped {} packets.".format(
                        reinjector_status.n_dropped_packet_overflows)))
            prov_items.add_provenance_item_by_location(
                placement, ProvenanceDataItem(
                    name="Reinjected",
                    item=reinjector_status.n_reinjected_packets,
                    needs_reporting_to_end_user=False))
